#!/bin/bash
#
# chkconfig: 345 90 50
# name: bigip-gw
# description: set routing for BigIP traffic on any acceptable interface. 
#              removes the need to SNAT a BigIP virtual.
#
# author: David Osborne <https://github.com/dfosborne2> 
#                        dosborne@us.ibm.com
# license: GNU General Public License v2, June 1991, 
#          Beer licensing also in effect here
#
# warranty: None...
#
#
# *** NOTICE ***
#
# INSTRUCTIONS: 
# 
#  Place in /etc/init.d of host you wish to add as a node to 
#  your BigIP loadbalancer.
# 
#  Enable it:
#
#  chkconfig <script_name> on
#  
#  To start it:
#
#  service <script_name> start 
#
#
#
# DETAILED INFORMATION::
#
# This script is a BigIP SNAT killer. This script negates 
# the need to SNAT your virtual address on your BigIP
#
# This script will check a specified number of interfaces
# on a server and then compare the broadcast address of it
# to the broadcast address of each BigIP floating address
# If they match, apply the routes and rules
#
#
#  THE SYSCONFIG FILE 
#
# A sysconfig file must be supplied as well
# to specify which interface you want to apply the bigip as a 
# conditional gateway:
#
#  /etc/sysconfig/bigip-gw
#
# Valid "IFACE_SELECTION" are 
#  all ifaces: "all"
#    -or-
#  a specific iface ex:  "eth3"
#    -or-
#  ""  (blank) - whice will use the iface which corresponds to
#                the FQDN of the host.
#
# By default, the "all" option is selected. Should a 
# /etc/sysconfig/bigip-gw not exist.
# 
# ADDITIONAL sysconfig vars::
#
# Currently, BIGIP_FLOATERS and MAC_MASQUERADE are the only 
# variables you'll need to setup. 
#
# By default, the vars are are assumed to be derived 
# by chef - tailor to your needs.
#
# The RT_TABLES sysconfig entry must be /etc/iproute2/rt_tables. No
# need to change/modify it for a typical usage of this script.


# Lets get started.

# Setup yer PATH!
PATH=:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
export PATH

# source function library
. /etc/rc.d/init.d/functions

# source sysconfig file
SYS_CONFIG="/etc/sysconfig/bigip-gw"

if [ -f ${SYS_CONFIG} ]; then
  source ${SYS_CONFIG}
else
  echo " *** CRITICAL - ${SYS_CONFIG} file missing. Please read over documentation inside this script! ***"
  exit 1
fi



# Support functions here

get_bcast()
{
#  1 input variable required
#
# $1 : Primary IP address of the interface under current
#      analysis
 
ipcalc -b ${1} |sed "s|BROADCAST=||g"

}

# The following "check" functions
# are failsafe measures which perform
# the action (add or del) only if it is needed.
# That way you wont wind up with lingering 
# artifacts in rt_tables or your iptables 
# config, etc..

check_mangle()
{ 
# One input variable required.
# $1 = interface
# $2 = fwmark integer

# Make sure mark exists before routing happens
# The first handles incoming packets

if ! (iptables -t mangle -L PREROUTING -v|grep "CONNMARK restore" > /dev/null); then
  iptables -t mangle -A PREROUTING  -j CONNMARK --restore-mark
fi

# The second handles outgoing packets
if ! (iptables -t mangle -L OUTPUT -v |grep "CONNMARK restore"  > /dev/null); then
  iptables -t mangle -A OUTPUT -j CONNMARK --restore-mark
fi

}


check_layer2_mac_rule()
{
# Four input variables required
# $1 = action (add -or  del)
# $2 = mac masquerade address
# $3 = comment for rule
# $4 = fwmark integer

# If action to add, then check for it and add if missing.
# else delete the rule when action is "not add"
if [ ${1} == "add" ]; then
  if ! (iptables -t mangle -L INPUT -v |grep -i ${2}|grep "${3}"  |grep "0x${4}" > /dev/null); then
    iptables -t mangle -A INPUT -m mac --mac-source ${2} -m comment --comment "${3}" -j MARK --set-mark 0x${4}
  fi
else
  iptables -t mangle -D INPUT -m mac --mac-source ${2} -m comment --comment "${3}" -j MARK --set-mark 0x${4}
fi
  

}


check_rule()
{
# 4 input variables required
#
# $1 : The action (add -or- del)
# $2 : The route metric (priority)
# $3 : The connmark value (fwmark 0x<int>)
# $4 : The table name as given in /etc/iproute2/rt_tables

# Check if the rule exists, act if not
if [ ${1} == "add" ]; then
  if ! (ip rule list |grep ${2} |grep ${3} |grep ${4} > /dev/null); then
    ip rule ${1} prio ${2} from all fwmark ${3} lookup ${4}
  fi
else
  ip rule ${1} prio ${2} from all fwmark ${3} lookup ${4}
fi
}


check_route()
{
#  5 input variables require
#
# $1 : The action (add -or- del)
# $2 : The table name as given in /etc/iproute2/rt_tables
# $3 : The gateway ip address you wish to use
# $4 : The interface to which you wish to apply the route
# $5 : The route metric (priority)
# $6 : The ip address 


if [ ${1} == "add" ]; then
  if ! (ip route show table 0 |grep ${2}|grep ${3} |grep ${4} > /dev/null); then
    ip route ${1} default via ${3} dev ${4} table ${2} metric ${5}  

  fi
else
  ip route ${1} default table ${2} via ${3} dev ${4} metric ${5}
fi

}


check_save_mark()
{
# 1 input variable require
#
# $1 : The action (add -or- del)

# Save your packet mark.
if [ ${1} == "add" ]; then
  if ! (iptables -L INPUT -t mangle -v |grep "CONNMARK save" > /dev/null); then
    iptables -t mangle -A INPUT -j CONNMARK --save-mark
  fi
else
  iptables -t mangle -D INPUT -j CONNMARK --save-mark
fi

}


check_rt_table()
{
#  3 input variables required
#
# $1 : The action (add -or- del)
# $2 : The table metric
# $3 : The table name
if [ ${1} == "add" ]; then
  if ! (grep "${2} ${3}" ${RT_TABLES} > /dev/null); then
    echo "${2} ${3}" >> ${RT_TABLES}
  fi
else
   sed -i "/^${2}.*$/d" ${RT_TABLES}
fi
}



# Start the main run of the script


route_manager()
{
# One input variable require
# $1 =  "add" or "del" 
# Dont worry we manage via stardd or stop 

ACTION=${1}

# Set some vars here (restart does funky things if 
# these vars are not set here!)
# Set some vars


ROUTE_METRIC=100
MARK_COUNT=1
TABLE_METRIC=201


# Get all the ifaces on the box
# /etc/sysconfig/bigip-gw is 
# sourced at the top of the file.
# Valid "IFACE_SELECTION" are 
#  "all" 
#    -or-
#  a specific iface ex:  "eth3"
#    -or-
#  ""  (blank) - whice will use the iface which corresponds to
#                the FQDN of the host.

# Also configured in /etc/sysconfig/bigip-gw are
# BIGIP_FLOATERS and MAC_MASQUERADE. 
# These two must configured and populated or the
# the script will bail.


if [ "${IFACE_SELECTION}" == "all" ]; then
   IFACE_ARRAY=($(ifconfig -s |egrep -v '^lo|^Iface'|awk '{print $1}'))

elif [ -z "${IFACE_SELECTION}" ]; then
  MY_IP=$(dig ${HOSTNAME} +short)
  IFACE_ARRAY=($(ip -o addr |grep ${MY_IP} |awk '{print $2}'))

else
  IFACE_ARRAY=($(ip -o addr |egrep ${IFACE_SELECTION} |awk '{print $2}'))
fi


for floater in ${BIGIP_FLOATERS[@]}; do
   for iface in ${IFACE_ARRAY[@]}; do
       APPLIED=no
       ip_addr=$(ip -o addr show ${iface}|grep -v secondary | awk '/inet /{print substr($4,0)}')
       if [ ! -z $ip_addr ]
         then
           BIGIP_BCAST=$(get_bcast ${floater})
           HOST_BCAST=$(get_bcast ${ip_addr})
           if [ $HOST_BCAST == $BIGIP_BCAST ]; then
             echo "Action: ${ACTION} rules/routes  $floater is the BIG-IP transit gateway for local address: ${ip_addr}."
             APPLIED=yes
           fi
         # If we match an iface's address broadcast to a floater's broadcast, let's
         # build or tear domw some rules/routes

         if [ $APPLIED == "yes" ]; then
           
           # Set the big ip floater as the gateway in this instance.
           BIGIP_GW=$(echo ${floater}|sed "s|/.*$||g")
           BIGIP_GW_NAME="bigip_gw_$(echo ${BIGIP_GW} |sed 's|\.|-|g')"

           if [ ${ACTION} == "del" ]; then
             # Delete rule and route
             check_rule ${ACTION} ${ROUTE_METRIC} ${MARK_COUNT} ${BIGIP_GW_NAME}
             check_route ${ACTION}  ${BIGIP_GW_NAME} ${BIGIP_GW} ${iface} ${ROUTE_METRIC} 

             # Flush corresponding mangle rule
             check_layer2_mac_rule ${ACTION} "${MAC_MASQUERADE}" "Rule:${BIGIP_GW_NAME}" ${MARK_COUNT}

             # Clean out the route table
             check_rt_table ${ACTION} ${TABLE_METRIC} ${BIGIP_GW_NAME}

           # If $ACTION is to "add", then let's add the stuff.
           else
             # Define the table for the route
             check_rt_table ${ACTION} ${TABLE_METRIC} ${BIGIP_GW_NAME}

             # Add route and rule
             check_route ${ACTION}  ${BIGIP_GW_NAME} ${BIGIP_GW} ${iface} ${ROUTE_METRIC} 
             check_rule ${ACTION} ${ROUTE_METRIC} ${MARK_COUNT} ${BIGIP_GW_NAME}


             # Now save  mark all packets 
             check_layer2_mac_rule ${ACTION} "${MAC_MASQUERADE}" "Rule:${BIGIP_GW_NAME}" ${MARK_COUNT}

           fi

           # Bump your counters
           MARK_COUNT=$((${MARK_COUNT} + 1))
           ROUTE_METRIC=$((${ROUTE_METRIC} + 10))
           TABLE_METRIC=$((${TABLE_METRIC} + 1))
         fi
       fi
     done
  done
}


start()
{
 route_manager add && \
 check_mangle && \
 check_save_mark add && \
 ip route flush cache &&
 service iptables save
}

stop(){
 route_manager del && \
 check_save_mark del && \
 ip route flush cache
}



case "$1" in
  start)
        start
        ;;
  stop)
        stop 
        ;;
  restart)
        stop
        start
        ;;
  *)
        echo $"Usage: $0 {start|stop|restart}"
        RETVAL=1
esac
